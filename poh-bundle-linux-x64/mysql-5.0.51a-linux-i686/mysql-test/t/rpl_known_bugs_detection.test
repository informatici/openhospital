# Test to see if slave can detect certain known bugs present
# on the master, and appropriately decides to stop
# (assuming the bug is fixed in the slave, slave cannot of course
# imitate the bug, so it has to stop).

source include/have_debug.inc;
source include/master-slave.inc;

#
# This is to test that slave properly detects if
# master may suffer from:
# BUG#24432 "INSERT... ON DUPLICATE KEY UPDATE skips auto_increment values"
# (i.e. on master, INSERT ON DUPLICATE KEY UPDATE is used and manipulates
# an auto_increment column, and is binlogged statement-based).
#

# testcase with INSERT VALUES
CREATE TABLE t1 (a INT NOT NULL PRIMARY KEY AUTO_INCREMENT, b INT,
UNIQUE(b));
sync_slave_with_master;
connection master;
INSERT INTO t1(b) VALUES(1),(1),(2) ON DUPLICATE KEY UPDATE t1.b=10;
SELECT * FROM t1;
connection slave;
wait_for_slave_to_stop;
# show the error message
--replace_column 1 # 4 # 7 # 8 # 9 # 23 # 33 #
--query_vertical show slave status;
# show that it was not replicated
SELECT * FROM t1;

# restart replication for the next testcase
stop slave;
reset slave;
connection master;
reset master;
drop table t1;
connection slave;
start slave;

# testcase with INSERT SELECT
connection master;
CREATE TABLE t1 (
  id bigint(20) unsigned NOT NULL auto_increment,
  field_1 int(10) unsigned NOT NULL,
  field_2 varchar(255) NOT NULL,
  field_3 varchar(255) NOT NULL,
  PRIMARY KEY (id),
  UNIQUE KEY field_1 (field_1, field_2)
);
CREATE TABLE t2 (
  field_a int(10) unsigned NOT NULL,
  field_b varchar(255) NOT NULL,
  field_c varchar(255) NOT NULL
);
INSERT INTO t2 (field_a, field_b, field_c) VALUES (1, 'a', '1a');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (2, 'b', '2b');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (3, 'c', '3c');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (4, 'd', '4d');
INSERT INTO t2 (field_a, field_b, field_c) VALUES (5, 'e', '5e');
sync_slave_with_master;
connection master;
# Updating table t1 based on values from table t2
INSERT INTO t1 (field_1, field_2, field_3)
SELECT t2.field_a, t2.field_b, t2.field_c
FROM t2
ON DUPLICATE KEY UPDATE
t1.field_3 = t2.field_c;
# Inserting new record into t2
INSERT INTO t2 (field_a, field_b, field_c) VALUES (6, 'f', '6f');
# Updating t1 again
INSERT INTO t1 (field_1, field_2, field_3)
SELECT t2.field_a, t2.field_b, t2.field_c
FROM t2
ON DUPLICATE KEY UPDATE
t1.field_3 = t2.field_c;
SELECT * FROM t1;
connection slave;
wait_for_slave_to_stop;
# show the error message
--replace_column 1 # 4 # 7 # 8 # 9 # 23 # 33 #
--query_vertical show slave status;
# show that it was not replicated
SELECT * FROM t1;
connection master;
drop table t1, t2;
connection slave;
drop table t1, t2;

# End of 5.0 tests
