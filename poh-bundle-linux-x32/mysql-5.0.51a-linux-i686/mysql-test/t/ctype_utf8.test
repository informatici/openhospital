#
# Tests with the utf8 character set
#

--disable_warnings
drop table if exists t1,t2;
--enable_warnings
set names utf8;

select left(_utf8 0xD0B0D0B1D0B2,1);
select right(_utf8 0xD0B0D0B2D0B2,1);

select locate('he','hello');
select locate('he','hello',2);
select locate('lo','hello',2);
select locate('HE','hello');
select locate('HE','hello',2);
select locate('LO','hello',2);
select locate('HE','hello' collate utf8_bin);
select locate('HE','hello' collate utf8_bin,2);
select locate('LO','hello' collate utf8_bin,2);

select locate(_utf8 0xD0B1, _utf8 0xD0B0D0B1D0B2);
select locate(_utf8 0xD091, _utf8 0xD0B0D0B1D0B2);
select locate(_utf8 0xD0B1, _utf8 0xD0B0D091D0B2);
select locate(_utf8 0xD091, _utf8 0xD0B0D0B1D0B2 collate utf8_bin);
select locate(_utf8 0xD0B1, _utf8 0xD0B0D091D0B2 collate utf8_bin);

select length(_utf8 0xD0B1), bit_length(_utf8 0xD0B1), char_length(_utf8 0xD0B1);

select 'a' like 'a';
select 'A' like 'a';
select 'A' like 'a' collate utf8_bin;
select _utf8 0xD0B0D0B1D0B2 like concat(_utf8'%',_utf8 0xD0B1,_utf8 '%');

# Bug #6040: can't retrieve records with umlaut
# characters in case insensitive manner.
# Case insensitive search LIKE comparison
# was broken for multibyte characters:
select convert(_latin1'G¸nter AndrÈ' using utf8) like CONVERT(_latin1'G‹NTER%' USING utf8);
select CONVERT(_koi8r'◊¡”—' USING utf8) LIKE CONVERT(_koi8r'˜·ÛÒ' USING utf8);
select CONVERT(_koi8r'˜·ÛÒ' USING utf8) LIKE CONVERT(_koi8r'◊¡”—' USING utf8);

#
# Check the following:
# "a"  == "a "
# "a\0" < "a"
# "a\0" < "a "

SELECT 'a' = 'a ';
SELECT 'a\0' < 'a';
SELECT 'a\0' < 'a ';
SELECT 'a\t' < 'a';
SELECT 'a\t' < 'a ';

#
# The same for binary collation
#
SELECT 'a' = 'a ' collate utf8_bin;
SELECT 'a\0' < 'a' collate utf8_bin;
SELECT 'a\0' < 'a ' collate utf8_bin;
SELECT 'a\t' < 'a' collate utf8_bin;
SELECT 'a\t' < 'a ' collate utf8_bin;

CREATE TABLE t1 (a char(10) character set utf8 not null);
INSERT INTO t1 VALUES ('a'),('a\0'),('a\t'),('a ');
SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1;
DROP TABLE t1;

#
# Fix this, it should return 1:
#
#select _utf8 0xD0B0D0B1D0B2 like concat(_utf8'%',_utf8 0xD091,_utf8 '%');
#

#
# Bug 2367: INSERT() behaviour is different for different charsets.
#
select insert('txs',2,1,'hi'),insert('is ',4,0,'a'),insert('txxxxt',2,4,'es');
select insert("aa",100,1,"b"),insert("aa",1,3,"b");

#
# LELF() didn't work well with utf8 in some cases too.
#
select char_length(left(@a:='—Ç–µ—Å—Ç',5)), length(@a), @a;


#
# CREATE ... SELECT
#
create table t1 select date_format("2004-01-19 10:10:10", "%Y-%m-%d");
show create table t1;
select * from t1;
drop table t1;

#
# Bug#22646 LC_TIME_NAMES: Assignment to non-UTF8 target fails
#
set names utf8;
set LC_TIME_NAMES='fr_FR';
create table t1 (s1 char(20) character set latin1);
insert into t1 values (date_format('2004-02-02','%M'));
select hex(s1) from t1;
drop table t1;
create table t1 (s1 char(20) character set koi8r);
set LC_TIME_NAMES='ru_RU';
insert into t1 values (date_format('2004-02-02','%M'));
insert into t1 values (date_format('2004-02-02','%b'));
insert into t1 values (date_format('2004-02-02','%W'));
insert into t1 values (date_format('2004-02-02','%a'));
select hex(s1), s1 from t1;
drop table t1;
set LC_TIME_NAMES='en_US';


#
# Bug #2366  	Wrong utf8 behaviour when data is truncated
#
set names koi8r;
create table t1 (s1 char(1) character set utf8);
insert into t1 values (_koi8r'¡¬');
select s1,hex(s1),char_length(s1),octet_length(s1) from t1;
drop table t1;

create table t1 (s1 tinytext character set utf8);
insert into t1 select repeat('a',300);
insert into t1 select repeat('—',300);
insert into t1 select repeat('a—',300);
insert into t1 select repeat('—a',300);
insert into t1 select repeat('——',300);
select hex(s1) from t1;
select length(s1),char_length(s1) from t1;
drop table t1;

create table t1 (s1 text character set utf8);
insert into t1 select repeat('a',66000);
insert into t1 select repeat('—',66000);
insert into t1 select repeat('a—',66000);
insert into t1 select repeat('—a',66000);
insert into t1 select repeat('——',66000);
select length(s1),char_length(s1) from t1;
drop table t1;

#
# Bug #2368 Multibyte charsets do not check that incoming data is well-formed
#
create table t1 (s1 char(10) character set utf8);
insert into t1 values (0x41FF);
select hex(s1) from t1;
drop table t1;

create table t1 (s1 varchar(10) character set utf8);
insert into t1 values (0x41FF);
select hex(s1) from t1;
drop table t1;

create table t1 (s1 text character set utf8);
insert into t1 values (0x41FF);
select hex(s1) from t1;
drop table t1;

#
# Bug 2699
# UTF8 breaks primary keys for cols > 333 characters
#
--error 1071
create table t1 (a text character set utf8, primary key(a(360)));


#
# Bug 2959
# UTF8 charset breaks joins with mixed column/string constant
#
CREATE TABLE t1 ( a varchar(10) ) CHARACTER SET utf8;
INSERT INTO t1 VALUES ( 'test' );
SELECT a.a, b.a FROM t1 a, t1 b WHERE a.a = b.a;
SELECT a.a, b.a FROM t1 a, t1 b WHERE a.a = 'test' and b.a = 'test';
SELECT a.a, b.a FROM t1 a, t1 b WHERE a.a = b.a and a.a = 'test';
DROP TABLE t1;

create table t1 (a char(255) character set utf8);
insert into t1 values('b'),('b');
select * from t1 where a = 'b';
select * from t1 where a = 'b' and a = 'b';
select * from t1 where a = 'b' and a != 'b';
drop table t1;

#
# Bug #3928 regexp [[:>:]] and UTF-8
#
set names utf8;

# This should return TRUE
select  '–≤–∞—Å—è'  rlike '[[:<:]]–≤–∞—Å—è[[:>:]]';
select  '–≤–∞—Å—è ' rlike '[[:<:]]–≤–∞—Å—è[[:>:]]';
select ' –≤–∞—Å—è'  rlike '[[:<:]]–≤–∞—Å—è[[:>:]]';
select ' –≤–∞—Å—è ' rlike '[[:<:]]–≤–∞—Å—è[[:>:]]';

# This should return FALSE
select  '–≤–∞—Å—èz' rlike '[[:<:]]–≤–∞—Å—è[[:>:]]';
select 'z–≤–∞—Å—è'  rlike '[[:<:]]–≤–∞—Å—è[[:>:]]';
select 'z–≤–∞—Å—èz' rlike '[[:<:]]–≤–∞—Å—è[[:>:]]';

#
# Bug #4555
# ALTER TABLE crashes mysqld with enum column collated utf8_unicode_ci
#
CREATE TABLE t1 (a enum ('Y', 'N') DEFAULT 'N' COLLATE utf8_unicode_ci);
ALTER TABLE t1 ADD COLUMN b CHAR(20);
DROP TABLE t1;

# Customer Support Center issue # 3299 
# ENUM and SET multibyte fields computed their length wronly 
# when converted into a char field
set names utf8;
create table t1 (a enum('aaaa','–ø—Ä–æ–±–∞') character set utf8);
show create table t1;
insert into t1 values ('–ø—Ä–æ–±–∞');
select * from t1;
create table t2 select ifnull(a,a) from t1;
show create table t2;
select * from t2;
drop table t1;
drop table t2;

#
# Bug 4521: unique key prefix interacts poorly with utf8
# MYISAM: keys with prefix compression, case insensitive collation.
#
create table t1 (c varchar(30) character set utf8, unique(c(10)));
insert into t1 values ('1'),('2'),('3'),('x'),('y'),('z');
insert into t1 values ('aaaaaaaaaa');
--error 1062
insert into t1 values ('aaaaaaaaaaa');
--error 1062
insert into t1 values ('aaaaaaaaaaaa');
insert into t1 values (repeat('b',20));
select c c1 from t1 where c='1';
select c c2 from t1 where c='2';
select c c3 from t1 where c='3';
select c cx from t1 where c='x';
select c cy from t1 where c='y';
select c cz from t1 where c='z';
select c ca10 from t1 where c='aaaaaaaaaa';
select c cb20 from t1 where c=repeat('b',20);
drop table t1;

#
# Bug 4521: unique key prefix interacts poorly with utf8
# InnoDB: keys with prefix compression, case insensitive collation.
#
--disable_warnings
create table t1 (c varchar(30) character set utf8, unique(c(10))) engine=innodb;
--enable_warnings
insert into t1 values ('1'),('2'),('3'),('x'),('y'),('z');
insert into t1 values ('aaaaaaaaaa');
--error 1062
insert into t1 values ('aaaaaaaaaaa');
--error 1062
insert into t1 values ('aaaaaaaaaaaa');
insert into t1 values (repeat('b',20));
select c c1 from t1 where c='1';
select c c2 from t1 where c='2';
select c c3 from t1 where c='3';
select c cx from t1 where c='x';
select c cy from t1 where c='y';
select c cz from t1 where c='z';
select c ca10 from t1 where c='aaaaaaaaaa';
select c cb20 from t1 where c=repeat('b',20);
drop table t1;
#
# Bug 4521: unique key prefix interacts poorly with utf8
# MYISAM: fixed length keys, case insensitive collation
#
create table t1 (c char(3) character set utf8, unique (c(2)));
insert into t1 values ('1'),('2'),('3'),('4'),('x'),('y'),('z');
insert into t1 values ('a');
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('b');
insert into t1 values ('bb');
--error 1062
insert into t1 values ('bbb');
insert into t1 values ('–∞');
insert into t1 values ('–∞–∞');
--error 1062
insert into t1 values ('–∞–∞–∞');
insert into t1 values ('–±');
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
insert into t1 values ('Í™™');
insert into t1 values ('Í™™Í™™');
--error 1062
insert into t1 values ('Í™™Í™™Í™™');
drop table t1;
#
# Bug 4521: unique key prefix interacts poorly with utf8
# InnoDB: fixed length keys, case insensitive collation
#
--disable_warnings
create table t1 (c char(3) character set utf8, unique (c(2))) engine=innodb;
--enable_warnings
insert into t1 values ('1'),('2'),('3'),('4'),('x'),('y'),('z');
insert into t1 values ('a');
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('b');
insert into t1 values ('bb');
--error 1062
insert into t1 values ('bbb');
insert into t1 values ('–∞');
insert into t1 values ('–∞–∞');
--error 1062
insert into t1 values ('–∞–∞–∞');
insert into t1 values ('–±');
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
insert into t1 values ('Í™™');
insert into t1 values ('Í™™Í™™');
--error 1062
insert into t1 values ('Í™™Í™™Í™™');
drop table t1;
#
# Bug 4531: unique key prefix interacts poorly with utf8
# Check HEAP+HASH, case insensitive collation
#
create table t1 (
c char(10) character set utf8,
unique key a using hash (c(1))
) engine=heap;
show create table t1;
insert into t1 values ('a'),('b'),('c'),('d'),('e'),('f');
--error 1062
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('–±');
--error 1062
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
select c as c_all from t1 order by c;
select c as c_a from t1 where c='a';
select c as c_a from t1 where c='–±';
drop table t1;

#
# Bug 4531: unique key prefix interacts poorly with utf8
# Check HEAP+BTREE, case insensitive collation
#
create table t1 (
c char(10) character set utf8,
unique key a using btree (c(1))
) engine=heap;
show create table t1;
insert into t1 values ('a'),('b'),('c'),('d'),('e'),('f');
--error 1062
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('–±');
--error 1062
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
select c as c_all from t1 order by c;
select c as c_a from t1 where c='a';
select c as c_a from t1 where c='–±';
drop table t1;

#
# Bug 4531: unique key prefix interacts poorly with utf8
# Check BDB, case insensitive collation
#
--disable_warnings
create table t1 (
c char(10) character set utf8,
unique key a (c(1))
) engine=bdb;
--enable_warnings
insert into t1 values ('a'),('b'),('c'),('d'),('e'),('f');
--error 1062
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('–±');
--error 1062
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
select c as c_all from t1 order by c;
select c as c_a from t1 where c='a';
select c as c_a from t1 where c='–±';
drop table t1;

#
# Bug 4521: unique key prefix interacts poorly with utf8
# MYISAM: keys with prefix compression, binary collation.
#
create table t1 (c varchar(30) character set utf8 collate utf8_bin, unique(c(10)));
insert into t1 values ('1'),('2'),('3'),('x'),('y'),('z');
insert into t1 values ('aaaaaaaaaa');
--error 1062
insert into t1 values ('aaaaaaaaaaa');
--error 1062
insert into t1 values ('aaaaaaaaaaaa');
insert into t1 values (repeat('b',20));
select c c1 from t1 where c='1';
select c c2 from t1 where c='2';
select c c3 from t1 where c='3';
select c cx from t1 where c='x';
select c cy from t1 where c='y';
select c cz from t1 where c='z';
select c ca10 from t1 where c='aaaaaaaaaa';
select c cb20 from t1 where c=repeat('b',20);
drop table t1;

#
# Bug 4521: unique key prefix interacts poorly with utf8
# MYISAM: fixed length keys, binary collation
#
create table t1 (c char(3) character set utf8 collate utf8_bin, unique (c(2)));
insert into t1 values ('1'),('2'),('3'),('4'),('x'),('y'),('z');
insert into t1 values ('a');
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('b');
insert into t1 values ('bb');
--error 1062
insert into t1 values ('bbb');
insert into t1 values ('–∞');
insert into t1 values ('–∞–∞');
--error 1062
insert into t1 values ('–∞–∞–∞');
insert into t1 values ('–±');
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
insert into t1 values ('Í™™');
insert into t1 values ('Í™™Í™™');
--error 1062
insert into t1 values ('Í™™Í™™Í™™');
drop table t1;

#
# Bug 4531: unique key prefix interacts poorly with utf8
# Check HEAP+HASH, binary collation
#
create table t1 (
c char(10) character set utf8 collate utf8_bin,
unique key a using hash (c(1))
) engine=heap;
show create table t1;
insert into t1 values ('a'),('b'),('c'),('d'),('e'),('f');
--error 1062
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('–±');
--error 1062
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
select c as c_all from t1 order by c;
select c as c_a from t1 where c='a';
select c as c_a from t1 where c='–±';
drop table t1;

#
# Bug 4531: unique key prefix interacts poorly with utf8
# Check HEAP+BTREE, binary collation
#
create table t1 (
c char(10) character set utf8 collate utf8_bin,
unique key a using btree (c(1))
) engine=heap;
show create table t1;
insert into t1 values ('a'),('b'),('c'),('d'),('e'),('f');
--error 1062
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('–±');
--error 1062
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
select c as c_all from t1 order by c;
select c as c_a from t1 where c='a';
select c as c_a from t1 where c='–±';
drop table t1;

#
# Bug 4531: unique key prefix interacts poorly with utf8
# Check BDB, binary collation
#
--disable_warnings
create table t1 (
c char(10) character set utf8 collate utf8_bin,
unique key a (c(1))
) engine=bdb;
--enable_warnings
insert into t1 values ('a'),('b'),('c'),('d'),('e'),('f');
--error 1062
insert into t1 values ('aa');
--error 1062
insert into t1 values ('aaa');
insert into t1 values ('–±');
--error 1062
insert into t1 values ('–±–±');
--error 1062
insert into t1 values ('–±–±–±');
select c as c_all from t1 order by c;
select c as c_a from t1 where c='a';
select c as c_a from t1 where c='–±';
drop table t1;


# Bug#4594: column index make = failed for gbk, but like works
# Check MYISAM
#
create table t1 (
  str varchar(255) character set utf8 not null,
  key str  (str(2))
) engine=myisam;
INSERT INTO t1 VALUES ('str');
INSERT INTO t1 VALUES ('str2');
select * from t1 where str='str';
drop table t1;

# Bug#4594: column index make = failed for gbk, but like works
# Check InnoDB
#
--disable_warnings
create table t1 (
  str varchar(255) character set utf8 not null,
  key str  (str(2))
) engine=innodb;
--enable_warnings
INSERT INTO t1 VALUES ('str');
INSERT INTO t1 VALUES ('str2');
select * from t1 where str='str';
drop table t1;

# the same for HEAP+BTREE
#

create table t1 (
  str varchar(255) character set utf8 not null,
  key str using btree (str(2))
) engine=heap;
INSERT INTO t1 VALUES ('str');
INSERT INTO t1 VALUES ('str2');
select * from t1 where str='str';
drop table t1;

# the same for HEAP+HASH
#

create table t1 (
  str varchar(255) character set utf8 not null,
  key str using hash (str(2))
) engine=heap;
INSERT INTO t1 VALUES ('str');
INSERT INTO t1 VALUES ('str2');
select * from t1 where str='str';
drop table t1;

# the same for BDB
#

--disable_warnings
create table t1 (
  str varchar(255) character set utf8 not null,
  key str (str(2))
) engine=bdb;
--enable_warnings
INSERT INTO t1 VALUES ('str');
INSERT INTO t1 VALUES ('str2');
select * from t1 where str='str';
drop table t1;

#
# Bug #5397: Crash with varchar binary and LIKE
#
CREATE TABLE t1 (a varchar(32) BINARY) CHARACTER SET utf8;
INSERT INTO t1 VALUES ('test');
SELECT a FROM t1 WHERE a LIKE '%te';
DROP TABLE t1;

#
# Bug #5723: length(<varchar utf8 field>) returns varying results
#
--disable_warnings
SET NAMES utf8;
--disable_warnings
CREATE TABLE t1 (
  subject varchar(255) character set utf8 collate utf8_unicode_ci,
  p varchar(15) character set utf8
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
--enable_warnings
INSERT INTO t1 VALUES ('Ë∞∑Â∑ù‰øä‰∫å„Å®Áî≥„Åó„Åæ„Åô„Åå„ÄÅ„Ç§„É≥„Çø„Éº„Éç„ÉÉ„Éà‰∫àÁ¥Ñ„ÅÆ‰ºöÂì°ÁôªÈå≤„Çí„Åó„Åæ„Åó„Åü„Å®„Åì„Çç„ÄÅ„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÇíÈñìÈÅï„Åà„Å¶„Åó„Åæ„ÅÑ‰ºöÂì°Ôº©Ôº§„ÅåÂèó„ÅëÂèñ„Çã„Åì„Å®„ÅåÂá∫Êù•„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÈñìÈÅï„Åà„Ç¢„Éâ„É¨„Çπ„ÅØtani-shun@n.vodafone.ne.jp„ÇíÊõ∏„ÅçËæº„Åø„Åæ„Åó„Åü„ÄÇ„Å©„ÅÜ„Åô„Çå„Å∞„Çà„ÅÑ„Åß„Åô„ÅãÔºü „Åù„ÅÆ‰ªñ„ÄÅ‰ΩèÊâÄÁ≠â„ÅØÈñìÈÅï„Åà„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÈÄ£Áµ°„Åè„Å†„Åï„ÅÑ„ÄÇ„Çà„Çç„Åó„Åè„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇm(__)m','040312-000057');
INSERT INTO t1 VALUES ('aaa','bbb');
SELECT length(subject) FROM t1;
SELECT length(subject) FROM t1 ORDER BY 1;
DROP TABLE t1;

#
# Bug #5832 SELECT doesn't return records in some cases
#
CREATE TABLE t1 (
    id       int unsigned NOT NULL auto_increment,
    list_id  smallint unsigned NOT NULL,
    term     TEXT NOT NULL,
    PRIMARY KEY(id),
    INDEX(list_id, term(4))
) ENGINE=MYISAM CHARSET=utf8;
INSERT INTO t1 SET list_id = 1, term = "letterc";
INSERT INTO t1 SET list_id = 1, term = "letterb";
INSERT INTO t1 SET list_id = 1, term = "lettera";
INSERT INTO t1 SET list_id = 1, term = "letterd";
SELECT id FROM t1 WHERE (list_id = 1) AND (term = "letterc");
SELECT id FROM t1 WHERE (list_id = 1) AND (term = "letterb");
SELECT id FROM t1 WHERE (list_id = 1) AND (term = "lettera");
SELECT id FROM t1 WHERE (list_id = 1) AND (term = "letterd");
DROP TABLE t1;


#
# Bug #6043 erratic searching for diacriticals in indexed MyISAM UTF-8 table
#
SET NAMES latin1;
CREATE TABLE t1 (
    id int unsigned NOT NULL auto_increment,
    list_id smallint unsigned NOT NULL,
    term text NOT NULL,
    PRIMARY KEY(id),
    INDEX(list_id, term(19))
) ENGINE=MyISAM CHARSET=utf8;
INSERT INTO t1 set list_id = 1, term = "testÈtest";
INSERT INTO t1 set list_id = 1, term = "testetest";
INSERT INTO t1 set list_id = 1, term = "testËtest";
SELECT id, term FROM t1 where (list_id = 1) AND (term = "testÈtest");
SELECT id, term FROM t1 where (list_id = 1) AND (term = "testetest");
SELECT id, term FROM t1 where (list_id = 1) AND (term = "testËtest");
DROP TABLE t1;

#
# Bug #6019 SELECT tries to use too short prefix index on utf8 data
#
set names utf8;
--disable_warnings
create table t1 (
  a int primary key,
  b varchar(6),
  index b3(b(3))
) engine=innodb character set=utf8;
--enable_warnings
insert into t1 values(1,'foo'),(2,'foobar');
select * from t1 where b like 'foob%';
--disable_warnings
alter table t1 engine=bdb;
--enable_warnings
select * from t1 where b like 'foob%';
drop table t1;

#
# Test for calculate_interval_lengths() function
#
create table t1 (
  a enum('–ø–µ—Ç—è','–≤–∞—Å—è','–∞–Ω—é—Ç–∞') character set utf8 not null default '–∞–Ω—é—Ç–∞',
  b set('–ø–µ—Ç—è','–≤–∞—Å—è','–∞–Ω—é—Ç–∞') character set utf8 not null default '–∞–Ω—é—Ç–∞'
);
create table t2 select concat(a,_utf8'') as a, concat(b,_utf8'')as b from t1;
show create table t2;
drop table t2;
drop table t1;

#
# Bug #6787 LIKE not working properly with _ and utf8 data
#
select 'c' like '\_' as want0; 

#
# SUBSTR with negative offset didn't work with multi-byte strings
#
SELECT SUBSTR('–≤–∞—Å—è',-2);


#
# Bug #7730 Server crash using soundex on an utf8 table
#
create table t1 (id integer, a varchar(100) character set utf8 collate utf8_unicode_ci);
insert into t1 values (1, 'Test');
select * from t1 where soundex(a) = soundex('Test');
select * from t1 where soundex(a) = soundex('TEST');
select * from t1 where soundex(a) = soundex('test');
drop table t1;

#
# Bug#22638 SOUNDEX broken for international characters
#
select soundex(_utf8 0xE99885E8A788E99A8FE697B6E69BB4E696B0E79A84E696B0E997BB);
select hex(soundex(_utf8 0xE99885E8A788E99A8FE697B6E69BB4E696B0E79A84E696B0E997BB));
select soundex(_utf8 0xD091D092D093);
select hex(soundex(_utf8 0xD091D092D093));


SET collation_connection='utf8_general_ci';
-- source include/ctype_filesort.inc
-- source include/ctype_like_escape.inc
SET collation_connection='utf8_bin';
-- source include/ctype_filesort.inc
-- source include/ctype_like_escape.inc

#
# Bug #7874 CONCAT() gives wrong results mixing
# latin1 field and utf8 string literals
#
CREATE TABLE t1 (
	user varchar(255) NOT NULL default ''
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO t1 VALUES ('one'),('two');
SELECT CHARSET('a');
SELECT user, CONCAT('<', user, '>') AS c FROM t1;
DROP TABLE t1;

#
# Bug#8785
# the same problem with the above, but with nested CONCATs
#
create table t1 (f1 varchar(1) not null) default charset utf8;
insert into t1 values (''), ('');
select concat(concat(_latin1'->',f1),_latin1'<-') from t1;
drop table t1;

#
# Bug#8385: utf8_general_ci treats Cyrillic letters I and SHORT I as the same
#
select convert(_koi8r'…' using utf8) < convert(_koi8r' ' using utf8);

#
# Bugs#5980: NULL requires a characterset in a union
#
set names latin1;
create table t1 (a varchar(10)) character set utf8;
insert into t1 values ('test');
select ifnull(a,'') from t1;
drop table t1;
select repeat(_utf8'+',3) as h union select NULL;
select ifnull(NULL, _utf8'string');

#
# Bug#9509 Optimizer: wrong result after AND with comparisons
#
set names utf8;
create table t1 (s1 char(5) character set utf8 collate utf8_lithuanian_ci);
insert into t1 values ('I'),('K'),('Y');
select * from t1 where s1 < 'K' and s1 = 'Y';
select * from t1 where 'K' > s1 and s1 = 'Y';
drop table t1;

create table t1 (s1 char(5) character set utf8 collate utf8_czech_ci);
insert into t1 values ('c'),('d'),('h'),('ch'),('CH'),('cH'),('Ch'),('i');
select * from t1 where s1 > 'd' and s1 = 'CH';
select * from t1 where 'd' < s1 and s1 = 'CH';
select * from t1 where s1 = 'cH' and s1 <> 'ch';
select * from t1 where 'cH' = s1 and s1 <> 'ch';
drop table t1;

#
# Bug#10714: Inserting double value into utf8 column crashes server
#
create table t1 (a varchar(255)) default character set utf8;
insert into t1 values (1.0);
drop table t1;

#
# Bug#10253 compound index length and utf8 char set
# produces invalid query results
#
create table t1 (
 id int not null,
 city varchar(20) not null,
 key (city(7),id)
) character set=utf8;
insert into t1 values (1,'Durban North');
insert into t1 values (2,'Durban');
select * from t1 where city = 'Durban';
select * from t1 where city = 'Durban ';
drop table t1;

#
# Bug #11819 CREATE TABLE with a SET DEFAULT 0 and UTF8 crashes server.
#
--error 1067
create table t1 (x set('A', 'B') default 0) character set utf8;
--error 1067
create table t1 (x enum('A', 'B') default 0) character set utf8;


#
# Test for bug #11167: join for utf8 varchar value longer than 255 bytes 
#

SET NAMES UTF8;

CREATE TABLE t1 (
  `id` int(20) NOT NULL auto_increment,
  `country` varchar(100) NOT NULL default '',
  `shortcode` varchar(100) NOT NULL default '',
  `operator` varchar(100) NOT NULL default '',
  `momid` varchar(30) NOT NULL default '',
  `keyword` varchar(160) NOT NULL default '',
  `content` varchar(160) NOT NULL default '',
  `second_token` varchar(160) default NULL,
  `gateway_id` int(11) NOT NULL default '0',
  `created` datetime NOT NULL default '0000-00-00 00:00:00',
  `msisdn` varchar(15) NOT NULL default '',
  PRIMARY KEY  (`id`),
  UNIQUE KEY `MSCCSPK_20030521130957121` (`momid`),
  KEY `IX_mobile_originated_message_keyword` (`keyword`),
  KEY `IX_mobile_originated_message_created` (`created`),
  KEY `IX_mobile_originated_message_support` (`msisdn`,`momid`,`keyword`,`gateway_id`,`created`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO t1 VALUES 
(1,'blah','464','aaa','fkc1c9ilc20x0hgae7lx6j09','ERR','ERR –ò–º—Ä–∏.–ê—Ñ–∏–º–∏–º.–ê–µ–∏–º–∏–º—Ä–∏–º–¥–º—Ä–∏–º—Ä–º—Ä–∏—Ä–æ—Ä –∏–º—Ä–∏–º—Ä–∏–º—Ä–∏–º—Ä –∏–º—Ä–∏–¥–º –∏—Ä–±–¥–Ω—Ä–∏–º—Ä—Ñ–º—Ä–∏—Ä–∏—Ä–∏–º—Ä—Ñ–º—Ñ–º–∏–º.–ê–¥.–î –∏–º–¥–∏–º—Ä–∏–º—Ä–∞–¥.–ê–¥–∏–º—Ä–∏–º—Ä–∏–º—Ä–º–¥–∏—Ä–∏–º—Ä–∏–º—Ä–∏–º—Ä –º.–î–∞–¥–∏–º—Ñ—à—å–º—Ä–∏–º–¥ –∏–º.–ê–¥–∏–º–∏–º—Ä–Ω –∏–º–∞–¥–º–∏','–ò–ú–†–ò.–ê–§–ò–ú–ò–ú.–ê–ï–ò–ú–ò–ú–†–ò–ú–î–ú–†–ò–ú–†–ú–†–ò–†–û–†',3,'2005-06-01 17:30:43','1234567890'),
(2,'blah','464','aaa','haxpl2ilc20x00bj4tt2m5ti','11','11 g','G',3,'2005-06-02 22:43:10','1234567890');

--disable_warnings
CREATE TABLE t2 (
  `msisdn` varchar(15) NOT NULL default '',
  `operator_id` int(11) NOT NULL default '0',
  `created` datetime NOT NULL default '0000-00-00 00:00:00',
  UNIQUE KEY `PK_user` (`msisdn`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
--enable_warnings

INSERT INTO t2 VALUES ('1234567890',2,'2005-05-24 13:53:25');

SELECT content, t2.msisdn FROM t1, t2 WHERE t1.msisdn = '1234567890';

DROP TABLE t1,t2;

#
# Bug#11591: CHAR column with utf8 does not work properly
# (more chars than expected)
#
create table t1 (a char(20) character set utf8);
insert into t1 values ('123456'),('–∞–Ω–¥—Ä–µ–π');
alter table t1 modify a char(2) character set utf8;
select char_length(a), length(a), a from t1 order by a;
drop table t1;

#
# Bugs#12611
# ESCAPE + LIKE do not work when the escape char is a multibyte one
#
set names utf8;
select 'andre%' like 'andre√±%' escape '√±';

#
# Bugs#11754: SET NAMES utf8 followed by SELECT "A\\" LIKE "A\\" returns 0
#
set names utf8;
select 'a\\' like 'a\\';
select 'aa\\' like 'a%\\';

create table t1 (a char(10), key(a)) character set utf8;
insert into t1 values ("a"),("abc"),("abcd"),("hello"),("test");
select * from t1 where a like "abc%";
select * from t1 where a like concat("abc","%");
select * from t1 where a like "ABC%";
select * from t1 where a like "test%";
select * from t1 where a like "te_t";
select * from t1 where a like "%a%";
select * from t1 where a like "%abcd%";
select * from t1 where a like "%abc\d%";
drop table t1;


#
# Bug#9557 MyISAM utf8 table crash
#
CREATE TABLE t1 (
  a varchar(255) NOT NULL default '',
  KEY a (a)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE utf8_general_ci;
insert into t1 values (_utf8 0xe880bd);
insert into t1 values (_utf8 0x5b);
select hex(a) from t1;
drop table t1;

#
# Bug#13751 find_in_set: Illegal mix of collations
#
set names 'latin1';
create table t1 (a varchar(255)) default charset=utf8;
select * from t1 where find_in_set('-1', a);
drop table t1;

#
# Bug#13233: select distinct char(column) fails with utf8
#
create table t1 (a int);
insert into t1 values (48),(49),(50);
set names utf8;
select distinct char(a) from t1;
drop table t1;

#
# Bug#15581: COALESCE function truncates mutli-byte TINYTEXT values
#
CREATE TABLE t1 (t TINYTEXT CHARACTER SET utf8);
INSERT INTO t1 VALUES(REPEAT('a', 100));
CREATE TEMPORARY TABLE t2 SELECT COALESCE(t) AS bug FROM t1;
SELECT LENGTH(bug) FROM t2;
DROP TABLE t2;
DROP TABLE t1;

#
# Bug#17313: N'xxx' and _utf8'xxx' are not equivalent
#
CREATE TABLE t1 (item varchar(255)) default character set utf8;
INSERT INTO t1 VALUES (N'\\');
INSERT INTO t1 VALUES (_utf8'\\');
INSERT INTO t1 VALUES (N'Cote d\'Ivoire');
INSERT INTO t1 VALUES (_utf8'Cote d\'Ivoire');
SELECT item FROM t1 ORDER BY item;
DROP TABLE t1;

#
# Bug#17705: Corruption of compressed index when index length changes between
# 254 and 256
#

SET NAMES utf8;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(a VARCHAR(255), KEY(a)) ENGINE=MyISAM DEFAULT CHARSET=utf8;
INSERT INTO t1 VALUES('uuABCDEFGHIGKLMNOPRSTUVWXYZÃàbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb');
INSERT INTO t1 VALUES('uu');
check table t1;
INSERT INTO t1 VALUES('uU');
check table t1;
INSERT INTO t1 VALUES('uu');
check table t1;
INSERT INTO t1 VALUES('uuABC');
check table t1;
INSERT INTO t1 VALUES('UuABC');
check table t1;
INSERT INTO t1 VALUES('uuABC');
check table t1;
alter table t1 add b int;
INSERT INTO t1 VALUES('uuABCDEFGHIGKLMNOPRSTUVWXYZÃàbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',1);
INSERT INTO t1 VALUES('uuABCDEFGHIGKLMNOPRSTUVWXYZÃàbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',2);
delete from t1 where b=1;
INSERT INTO t1 VALUES('UUABCDEFGHIGKLMNOPRSTUVWXYZÃàbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',1);
check table t1;
INSERT INTO t1 VALUES('uuABCDEFGHIGKLMNOPRSTUVWXYZÃàbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',3);
INSERT INTO t1 VALUES('uuABCDEFGHIGKLMNOPRSTUVWXYZÃàbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',4);
delete from t1 where b=3;
INSERT INTO t1 VALUES('uUABCDEFGHIGKLMNOPRSTUVWXYZÃàbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',3);
check table t1;
drop table t1;

#
# Bug#20471 LIKE search fails with indexed utf8 char column
#
set names utf8;
create table t1 (s1 char(5) character set utf8);
insert into t1 values
('a'),('b'),(null),('„Éö„ÉÜ„É´„Ç∞„É´'),('√º'),('Y');
create index it1 on t1 (s1);
select s1 as before_delete_general_ci from t1 where s1 like '„Éö„ÉÜ%';
delete from t1 where s1 = 'Y';
select s1 as after_delete_general_ci from t1 where s1 like '„Éö„ÉÜ%';
drop table t1;

set names utf8;
create table t1 (s1 char(5) character set utf8 collate utf8_unicode_ci);
insert into t1 values
('a'),('b'),(null),('„Éö„ÉÜ„É´„Ç∞„É´'),('√º'),('Y');
create index it1 on t1 (s1);
select s1 as before_delete_unicode_ci from t1 where s1 like '„Éö„ÉÜ%';
delete from t1 where s1 = 'Y';
select s1 as after_delete_unicode_ci from t1 where s1 like '„Éö„ÉÜ%';
drop table t1;

set names utf8;
create table t1 (s1 char(5) character set utf8 collate utf8_bin);
insert into t1 values
('a'),('b'),(null),('„Éö„ÉÜ„É´„Ç∞„É´'),('√º'),('Y');
create index it1 on t1 (s1);
select s1 as before_delete_bin from t1 where s1 like '„Éö„ÉÜ%';
delete from t1 where s1 = 'Y';
select s1 as after_delete_bin from t1 where s1 like '„Éö„ÉÜ%';
drop table t1;

# additional tests from duplicate bug#20744 MySQL return no result

set names utf8;
--disable_warnings
create table t1 (a varchar(30) not null primary key)
engine=innodb  default character set utf8 collate utf8_general_ci;
--enable_warnings
insert into t1 values ('„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù');
insert into t1 values ('„Åï„Åó„Åô„Åõ„Åù„Åã„Åç„Åè„Åë„Åì„ÅÇ„ÅÑ„ÅÜ„Åà„Åä');
select a as gci1 from t1 where a like '„Åï„Åó„Åô„Åõ„Åù„Åã„Åç„Åè„Åë„Åì„ÅÇ„ÅÑ„ÅÜ„Åà„Åä%';
select a as gci2 from t1 where a like '„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù';
drop table t1;

set names utf8;
--disable_warnings
create table t1 (a varchar(30) not null primary key)
engine=innodb default character set utf8 collate utf8_unicode_ci;
--enable_warnings
insert into t1 values ('„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù');
insert into t1 values ('„Åï„Åó„Åô„Åõ„Åù„Åã„Åç„Åè„Åë„Åì„ÅÇ„ÅÑ„ÅÜ„Åà„Åä');
select a as uci1 from t1 where a like '„Åï„Åó„Åô„Åõ„Åù„Åã„Åç„Åè„Åë„Åì„ÅÇ„ÅÑ„ÅÜ„Åà„Åä%';
select a as uci2 from t1 where a like '„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù';
drop table t1;

set names utf8;
--disable_warnings
create table t1 (a varchar(30) not null primary key)
engine=innodb default character set utf8 collate utf8_bin;
--enable_warnings
insert into t1 values ('„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù');
insert into t1 values ('„Åï„Åó„Åô„Åõ„Åù„Åã„Åç„Åè„Åë„Åì„ÅÇ„ÅÑ„ÅÜ„Åà„Åä');
select a as bin1 from t1 where a like '„Åï„Åó„Åô„Åõ„Åù„Åã„Åç„Åè„Åë„Åì„ÅÇ„ÅÑ„ÅÜ„Åà„Åä%';
select a as bin2 from t1 where a like '„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù';
drop table t1;



#
# Bug#14896: Comparison with a key in a partial index over mb chararacter field
#

SET NAMES utf8;
CREATE TABLE t1 (id int PRIMARY KEY,
                 a varchar(16) collate utf8_unicode_ci NOT NULL default '',
                 b int,
                 f varchar(128) default 'XXX',
                 INDEX (a(4))
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
INSERT INTO t1(id, a, b) VALUES
  (1, 'cccc', 50), (2, 'cccc', 70), (3, 'cccc', 30),
  (4, 'cccc', 30), (5, 'cccc', 20), (6, 'bbbbbb', 40),
  (7, 'dddd', 30), (8, 'aaaa', 10), (9, 'aaaa', 50),
  (10, 'eeeee', 40), (11, 'bbbbbb', 60);

SELECT id, a, b FROM t1;

SELECT id, a, b FROM t1 WHERE a BETWEEN 'aaaa' AND 'bbbbbb';

SELECT id, a FROM t1 WHERE a='bbbbbb';
SELECT id, a FROM t1 WHERE a='bbbbbb' ORDER BY b;

DROP TABLE t1;

#
# Bug#16674: LIKE predicate for a utf8 character set column
#

SET NAMES utf8;

CREATE TABLE t1 (
  a CHAR(13) DEFAULT '',
  INDEX(a)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;
INSERT INTO t1 VALUES 
 ('K√§li K√§li 2-4'), ('K√§li K√§li 2-4'),
 ('K√§li K√§li 2+4'), ('K√§li K√§li 2+4'),
 ('K√§li K√§li 2-6'), ('K√§li K√§li 2-6');
INSERT INTO t1 SELECT * FROM t1;

CREATE TABLE t2 (
  a CHAR(13) DEFAULT '',
  INDEX(a)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

INSERT INTO t2 VALUES
 ('Kali Kali 2-4'), ('Kali Kali 2-4'),
 ('Kali Kali 2+4'), ('Kali Kali 2+4'),
 ('Kali Kali 2-6'), ('Kali Kali 2-6');
INSERT INTO t2 SELECT * FROM t2;

SELECT a FROM t1 WHERE a LIKE 'K√§li K√§li 2+4';
SELECT a FROM t2 WHERE a LIKE 'Kali Kali 2+4';

EXPLAIN SELECT a FROM t1 WHERE a LIKE 'K√§li K√§li 2+4';
EXPLAIN SELECT a FROM t1 WHERE a = 'K√§li K√§li 2+4';
EXPLAIN SELECT a FROM t2 WHERE a LIKE 'Kali Kali 2+4';
EXPLAIN SELECT a FROM t2 WHERE a = 'Kali Kali 2+4';

DROP TABLE t1,t2;

CREATE TABLE t1 (
  a char(255) DEFAULT '', 
  KEY(a(10))
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;
INSERT INTO t1 VALUES ('K√§li K√§li 2-4');
SELECT * FROM t1 WHERE a LIKE 'K√§li K√§li 2%';
INSERT INTO t1 VALUES ('K√§li K√§li 2-4');
SELECT * FROM t1 WHERE a LIKE 'K√§li K√§li 2%';
DROP TABLE t1;

CREATE TABLE t1 (
  a char(255) DEFAULT ''
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;
INSERT INTO t1 VALUES ('K√§li K√§li 2-4');
INSERT INTO t1 VALUES ('K√§li K√§li 2-4');
SELECT * FROM t1 WHERE a LIKE 'K√§li K√§li 2%';
ALTER TABLE t1 ADD KEY (a(10));
SELECT * FROM t1 WHERE a LIKE 'K√§li K√§li 2%';
DROP TABLE t1;

#
# Bug#18359: LIKE predicate for a 'utf8' text column with a partial index
#            (see bug #16674 as well)
#

SET NAMES latin2;

CREATE TABLE t1 (
  id int(11) NOT NULL default '0',
  tid int(11) NOT NULL default '0',
  val text NOT NULL,
  INDEX idx(tid, val(10))
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO t1 VALUES
  (40988,72,'VOLN› ADSL'),(41009,72,'VOLN› ADSL'),
  (41032,72,'VOLN› ADSL'),(41038,72,'VOLN› ADSL'),
  (41063,72,'VOLN› ADSL'),(41537,72,'VOLN› ADSL Office'),
  (42141,72,'VOLN› ADSL'),(42565,72,'VOLN› ADSL Combi'),
  (42749,72,'VOLN› ADSL'),(44205,72,'VOLN› ADSL');

SELECT * FROM t1 WHERE tid=72 and val LIKE 'VOLNY ADSL'; 
SELECT * FROM t1 WHERE tid=72 and val LIKE 'VOLN› ADSL'; 
SELECT * FROM t1 WHERE tid=72 and val LIKE '%VOLN› ADSL'; 

ALTER TABLE t1 DROP KEY idx;
ALTER TABLE t1 ADD KEY idx (tid,val(11));

SELECT * FROM t1 WHERE tid=72 and val LIKE 'VOLN› ADSL'; 

DROP TABLE t1;

#
# Bug 20709: problem with utf8 fields in temporary tables
#

create table t1(a char(200) collate utf8_unicode_ci NOT NULL default '')
  default charset=utf8 collate=utf8_unicode_ci;
insert into t1 values (unhex('65')), (unhex('C3A9')), (unhex('65'));
explain select distinct a from t1;
select distinct a from t1;
explain select a from t1 group by a;
select a from t1 group by a;
drop table t1;

#
# Bug #20204: "order by" changes the results returned
#

create table t1(a char(10)) default charset utf8;
insert into t1 values ('123'), ('456');
explain
  select substr(Z.a,-1), Z.a from t1 as Y join t1 as Z on Y.a=Z.a order by 1;
select substr(Z.a,-1), Z.a from t1 as Y join t1 as Z on Y.a=Z.a order by 1;
drop table t1;
# End of 4.1 tests

#
# Test for bug #11484: wrong results for a DISTINCT varchar column in uft8. 
#

CREATE TABLE t1(id varchar(20) NOT NULL) DEFAULT CHARSET=utf8;
INSERT INTO t1 VALUES ('xxx'), ('aa'), ('yyy'), ('aa');

SELECT id FROM t1;
SELECT DISTINCT id FROM t1;
SELECT DISTINCT id FROM t1 ORDER BY id;

DROP TABLE t1;

#
# Bug#20095 Changing length of VARCHAR field with UTF8
# collation does not truncate values
#
create table t1 (
  a varchar(26) not null
) default character set utf8;
insert into t1 (a) values ('abcdefghijklmnopqrstuvwxyz');
select * from t1;
# varchar to varchar
alter table t1 change a a varchar(20) character set utf8 not null;
select * from t1;
# varchar to char
alter table t1 change a a char(15) character set utf8 not null;
select * from t1;
# char to char
alter table t1 change a a char(10) character set utf8 not null;
select * from t1;
# char to varchar
alter table t1 change a a varchar(5) character set utf8 not null;
select * from t1;
drop table t1;

#
# Check that do_varstring2_mb produces a warning
#
create table t1 (
  a varchar(4000) not null
) default character set utf8;
insert into t1 values (repeat('a',4000));
alter table t1 change a a varchar(3000) character set utf8 not null;
select length(a) from t1;
drop table t1;


#
#  Bug#10504: Character set does not support traditional mode
#  Bug#14146: CHAR(...USING ...) and CONVERT(CHAR(...) USING...)
#             produce different results
#
set names utf8;
# correct value
select hex(char(1 using utf8));
select char(0xd1,0x8f using utf8);
select char(0xd18f using utf8);
select char(53647 using utf8);
# incorrect value: return with warning
select char(0xff,0x8f using utf8);
select convert(char(0xff,0x8f) using utf8);
# incorrect value in strict mode: return NULL with "Error" level warning
set sql_mode=traditional;
select char(0xff,0x8f using utf8);
select char(195 using utf8);
select char(196 using utf8);
select char(2557 using utf8);
select convert(char(0xff,0x8f) using utf8);

#
# Check convert + char + using
#
select hex(convert(char(2557 using latin1) using utf8));

#
# char() without USING returns "binary" by default, any argument is ok
#
select hex(char(195));
select hex(char(196));
select hex(char(2557));



#
# Bug#12891: UNION doesn't return DISTINCT result for multi-byte characters
#
set names utf8;
create table t1 (a char(1)) default character set utf8;
create table t2 (a char(1)) default character set utf8;
insert into t1 values('a'),('a'),(0xE38182),(0xE38182);
insert into t1 values('i'),('i'),(0xE38184),(0xE38184);
select * from t1 union distinct select * from t2;
drop table t1,t2;


#
# Bug#12371: executing prepared statement fails (illegal mix of collations)
#
set names utf8;
create table t1 (a char(10), b varchar(10));
insert into t1 values ('bar','kostja');
insert into t1 values ('kostja','bar');
prepare my_stmt from "select * from t1 where a=?";
set @a:='bar';
execute my_stmt using @a;
set @a:='kostja';
execute my_stmt using @a;
set @a:=null;
execute my_stmt using @a;
drop table if exists t1;


#
# Bug#21505 Create view - illegal mix of collation for operation 'UNION'
#
--disable_warnings
drop table if exists t1;
drop view if exists v1, v2;
--enable_warnings
set names utf8;
create table t1(col1 varchar(12) character set utf8 collate utf8_unicode_ci);
insert into t1 values('t1_val');
create view v1 as select 'v1_val' as col1;
select coercibility(col1), collation(col1) from v1;
create view v2 as select col1 from v1 union select col1 from t1;
select coercibility(col1), collation(col1)from v2;
drop view v1, v2;
create view v1 as select 'v1_val' collate utf8_swedish_ci as col1;
select coercibility(col1), collation(col1) from v1;
create view v2 as select col1 from v1 union select col1 from t1;
select coercibility(col1), collation(col1) from v2;
drop view v1, v2;
drop table t1;

#
# Check conversion of NCHAR strings to subset (e.g. latin1).
# Conversion is possible if string repertoire is ASCII.
# Conversion is not possible if the string have extended characters
#
set names utf8;
create table t1 (a varchar(10) character set latin1, b int);
insert into t1 values ('a',1);
select concat(a, if(b>10, N'x', N'y')) from t1;
--error 1267
select concat(a, if(b>10, N'√¶', N'√ü')) from t1;
drop table t1;

# Conversion tests for character set introducers
set names utf8;
create table t1 (a varchar(10) character set latin1, b int);
insert into t1 values ('a',1);
select concat(a, if(b>10, _utf8'x', _utf8'y')) from t1;
--error 1267
select concat(a, if(b>10, _utf8'√¶', _utf8'√ü')) from t1;
drop table t1;

# Conversion tests for introducer + HEX string
set names utf8;
create table t1 (a varchar(10) character set latin1, b int);
insert into t1 values ('a',1);
select concat(a, if(b>10, _utf8 0x78, _utf8 0x79)) from t1;
--error 1267
select concat(a, if(b>10, _utf8 0xC3A6, _utf8 0xC3AF)) from t1;
drop table t1;

# Conversion tests for "text_literal TEXT_STRING_literal" syntax structure
set names utf8;
create table t1 (a varchar(10) character set latin1, b int);
insert into t1 values ('a',1);
select concat(a, if(b>10, 'x' 'x', 'y' 'y')) from t1;
--error 1267
select concat(a, if(b>10, 'x' '√¶', 'y' '√ü')) from t1;
drop table t1;


#
# Bug#19960: Inconsistent results when joining
# InnoDB tables using partial UTF8 indexes
#
--disable_warnings
CREATE TABLE t1 (
  colA int(11) NOT NULL,
  colB varchar(255) character set utf8 NOT NULL,
   PRIMARY KEY  (colA)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
--enable_warnings
INSERT INTO t1 (colA, colB) VALUES (1, 'foo'), (2, 'foo bar');
--disable_warnings
CREATE TABLE t2 (
  colA int(11) NOT NULL,
  colB varchar(255) character set utf8 NOT NULL,
   KEY bad  (colA,colB(3))
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
--enable_warnings
INSERT INTO t2 (colA, colB) VALUES (1, 'foo'),(2, 'foo bar');
SELECT * FROM t1 JOIN t2 ON t1.colA=t2.colA AND t1.colB=t2.colB
WHERE t1.colA < 3;
DROP TABLE t1, t2;

#
# Bug#29205: truncation of UTF8 values when the UNION statement
# forces collation to the binary charset
#

SELECT '–Ω1234567890' UNION SELECT _binary '1';
SELECT '–Ω1234567890' UNION SELECT 1;

SELECT '1' UNION SELECT '–Ω1234567890';
SELECT 1 UNION SELECT '–Ω1234567890';

CREATE TABLE t1 (c VARCHAR(11)) CHARACTER SET utf8;
CREATE TABLE t2 (b CHAR(1) CHARACTER SET binary, i INT);

INSERT INTO t1 (c) VALUES ('–Ω1234567890');
INSERT INTO t2 (b, i) VALUES ('1', 1);

SELECT c FROM t1 UNION SELECT b FROM t2;
SELECT c FROM t1 UNION SELECT i FROM t2;

SELECT b FROM t2 UNION SELECT c FROM t1;
SELECT i FROM t2 UNION SELECT c FROM t1;

DROP TABLE t1, t2;
